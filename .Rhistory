}
# Correct Encoding if necessary
# TODO: change index name to either badewetter_index.geojson or index.geojson
for(name in names){
if(name != "badewetter"){
assign(name, convert_to_correct_encoding(get(name)), name)
}
}
# Correct Encoding if necessary
# TODO: change index name to either badewetter_index.geojson or index.geojson
for(name in names){
if(name != "badewetter"){
assign(name, convert_to_correct_encoding(get(name), name))
}
}
swissLakes
kantone_lines
plot(kantone_lines)
plot(badewetter)
plt <- plot(kantone_lines)
rm(plt)
plot(kantone_lines)
plot(swissLakes, add=True)
plot(swissLakes, add=TRUE)
plot(swissLakes, add=TRUE, col="blue")
plot(swissLakes, color="blue",  add=TRUE)
plot(kantone_lines)
plot(swissLakes, color="blue",  add=TRUE)
kantone_lines
plot(kantone_lines["ID2"])
plot(swissLakes, col="blue", add=TRUE)
swissLakes
plot(swissLakes["ID2"], col="blue", add=TRUE)
plot(swissLakes["ID2"], color="blue", add=TRUE)
plot(swissLakes["ID2"], add=TRUE)
badwetter
badewetter
plot(badewetter["Höhe"], add=T)
plot(badewetter["Höhe"])
st_crs(badewetter)
badewetter
st_crs(swissLakes)
swissLakes
st_crs(kantone_lines)
kantone_lines
test <- as.data.frame(badewetter)
test
colnames(test)
test["geometry"]
st_as_text(test["geometry"])
st_as_text(test[,"geometry"])
st_coordinates(test)
st_coordinates(test["geometry"])
st_coordinates(test[,"geometry"])
sf_object <- test
proj_sf <- st_crs(sf_object)
proj_sf
test <- st_as_sf(test)
sf_object <- test
proj_sf <- st_crs(sf_object)
proj_sf
no_sf <- as.data.frame(sf_object)
coords <- st_coordinates(no_sf[,"geometry"])
coords
dim(coords)
max(coords[,1]) > 600000
st_set_crs(test)
st_set_crs(test, 21781)
?write.csv
getwd(9)
getwd()
ls
getwd()
setwd("./test/")
getwd()
list.files
list.files()
files <- list.files()
file.remove(files)
list.files()
setwd("..")
getwd()
?png
library(raster)
test = matrix(100, ncol=10)
plot(test)
raster::plot(test)
matplot(test)
?matplot
image(test)
dim(test)
test = matrix(100, ncol=10)
dim(test)
test = matrix(rep(10,100), ncol=10)
dim(test)
test[,5:10] <- 500
image(test)
test[,5:10] <- 50
image(test)
test[,5:10] <- 20
image(test)
test[,5:10]
test
test[,8:10] <- 30
image(test)
test[,1:5] <- 30
image(test)
test[,] <- 30
image(test)
test[1:4,] <- 30
test[4:8,] <- 30
test[1:4,] <- 20
image(test)
test[8:10,] <- 40
image(test)
?write.csv
library(sf)
library(raster)
#library(rjson)
library(tools)
library(geojsonsf)
###################################################################################################
# Section 0: Auxiliary Functions
# Function converts dataset to correct encoding
# takes and returns sf-object
convert_to_correct_encoding <- function(sf_object, type_of_data){
no_sf <- as.data.frame(sf_object)
# convert to correct encoding
if(type_of_data == "kantone_lines"){
Encoding(no_sf$ID1) <- "UTF-8"
}
if(type_of_data == "swissLakes"){
Encoding(no_sf$ID1) <- "UTF-8"
}
# if(any(type_of_data == c("lakes","kantone_lines"))){
#
#   no_sf$ID1 <- iconv(no_sf$ID1, from="ISO-8859-1", to="UTF-8")
#
# }
return(st_as_sf(no_sf))
}
###################################################################################################
# Section 1: SETTINGS
# TODO: check which projections are most practical to use in R
# possible destination crs:
# EPSG: 21781 (swiss projection), 3857 (pseudo-mercator), 2056 (LV95), 4326 (WGS84)
path <-  "data"
# Choose Destination CRS
which_crs <- "LV95"
# CRS-names and EPSG-codes
possible_crs <- c("Swiss Projection", "Pseudo-Mercator", "LV95", "WGS84")
epsg <- c(21781, 3857, 2056, 4326)
index_crs <- which(possible_crs == which_crs)
# Set-up destination projection specifications
dest_crs <- possible_crs[index_crs]
dest_epsg <- epsg[index_crs]
# Reading map-resources files
map_resources <- list.files(paste(path, "map_resources", sep = "/"))
# Check if Map-Resources exist
if(length(map_resources) == 0){
print("No Map-Resources available!")
#quit(status = 99)
}
# Check if all filetypes are GeoJSON
if(!all(file_ext(map_resources) %in% c("geojson", "json"))){
print("Not all files provided are either of type GeoJSON or JSON!")
#quit(status = 99)
}
names <- rep(NA, length(map_resources))
for(i in 1:length(map_resources)){
correct <- strsplit(map_resources[i], "[.]")[[1]][1]
names[i] <- correct
}
# Read-in all map-resources
for(i in 1:length(map_resources)){
assign(names[i], geojson_sf(paste(path, "map_resources", map_resources[i], sep = "/")))
}
dest_crs
possible_crs
typeof(badewetter)
class(badewetter)
test = badewetter
test = as.data.frame(test)
coords <- st_coordinates(test[, "geometry"])
coords
possible_crs
badewetter
kantone_lines
badewetter
getwd()
rm(badewetter)
geojson_sf("data/map_resources/badewetter.geojson")
# Reproject all files into the same coordinate system
# libraries
library(sf)
library(raster)
#library(rjson)
library(tools)
library(geojsonsf)
###################################################################################################
# Section 0: Auxiliary Functions
# Function converts dataset to correct encoding
# takes and returns sf-object
convert_to_correct_encoding <- function(sf_object, type_of_data){
no_sf <- as.data.frame(sf_object)
# convert to correct encoding
if(type_of_data == "kantone_lines"){
Encoding(no_sf$ID1) <- "UTF-8"
}
if(type_of_data == "swissLakes"){
Encoding(no_sf$ID1) <- "UTF-8"
}
# if(any(type_of_data == c("lakes","kantone_lines"))){
#
#   no_sf$ID1 <- iconv(no_sf$ID1, from="ISO-8859-1", to="UTF-8")
#
# }
return(st_as_sf(no_sf))
}
###################################################################################################
# Section 1: SETTINGS
# TODO: check which projections are most practical to use in R
# possible destination crs:
# EPSG: 21781 (swiss projection), 3857 (pseudo-mercator), 2056 (LV95), 4326 (WGS84)
path <-  "data"
# Choose Destination CRS
which_crs <- "LV95"
# CRS-names and EPSG-codes
possible_crs <- c("Swiss Projection", "Pseudo-Mercator", "LV95", "WGS84")
epsg <- c(21781, 3857, 2056, 4326)
index_crs <- which(possible_crs == which_crs)
# Set-up destination projection specifications
dest_crs <- possible_crs[index_crs]
dest_epsg <- epsg[index_crs]
# Reading map-resources files
map_resources <- list.files(paste(path, "map_resources", sep = "/"))
# Check if Map-Resources exist
if(length(map_resources) == 0){
print("No Map-Resources available!")
#quit(status = 99)
}
# Check if all filetypes are GeoJSON
if(!all(file_ext(map_resources) %in% c("geojson", "json"))){
print("Not all files provided are either of type GeoJSON or JSON!")
#quit(status = 99)
}
names <- rep(NA, length(map_resources))
for(i in 1:length(map_resources)){
correct <- strsplit(map_resources[i], "[.]")[[1]][1]
names[i] <- correct
}
# Read-in all map-resources
for(i in 1:length(map_resources)){
assign(names[i], geojson_sf(paste(path, "map_resources", map_resources[i], sep = "/")))
}
# Correct Encoding if necessary
# TODO: change index name to either badewetter_index.geojson or index.geojson
for(name in names){
if(name != "badewetter"){
assign(name, convert_to_correct_encoding(get(name), name))
}
}
badewetter
st_crs(badewetter)
st_crs(kantone_lines)
st_crs(swissLakes)
swiss
?swiss
possible_crs
index_crs
epsg
?crs
?CRS
CRS("+init=epsg:21781")
test = CRS("+init=epsg:21781")
test
test$1
test$init
str(test)
test2 = st_crs(badewetter)
test2 == test
getSlots(test)
class(test)
class(test2)
tesr
test
test2
proj4string(test)
proj4string(test2)
proj4string(badewetter)
methods("sf")
methods(sf)
compareCRS(test, test2)
test
test2
test3 = st_crs(badewetter)
test3
compareCRS(test2, test3)
# libraries
library(sf)
#library(raster)
#library(rjson)
library(tools)
library(geojsonsf)
###################################################################################################
# Section 0: Auxiliary Functions
# Function converts dataset to correct encoding
# takes and returns sf-object
convert_to_correct_encoding <- function(sf_object, type_of_data){
no_sf <- as.data.frame(sf_object)
# convert to correct encoding
if(type_of_data == "kantone_lines"){
Encoding(no_sf$ID1) <- "UTF-8"
}
if(type_of_data == "swissLakes"){
Encoding(no_sf$ID1) <- "UTF-8"
}
# if(any(type_of_data == c("lakes","kantone_lines"))){
#
#   no_sf$ID1 <- iconv(no_sf$ID1, from="ISO-8859-1", to="UTF-8")
#
# }
return(st_as_sf(no_sf))
}
###################################################################################################
# Section 1: SETTINGS
# TODO: check which projections are most practical to use in R
# possible destination crs:
# EPSG: 21781 (swiss projection), 3857 (pseudo-mercator), 2056 (LV95), 4326 (WGS84)
path <-  "data"
# Choose Destination CRS
which_crs <- "LV95"
# CRS-names and EPSG-codes
possible_crs <- c("Swiss Projection", "Pseudo-Mercator", "LV95", "WGS84")
epsg <- c(21781, 3857, 2056, 4326)
index_crs <- which(possible_crs == which_crs)
# Set-up destination projection specifications
dest_crs <- possible_crs[index_crs]
dest_epsg <- epsg[index_crs]
# Reading map-resources files
map_resources <- list.files(paste(path, "map_resources", sep = "/"))
# Check if Map-Resources exist
if(length(map_resources) == 0){
print("No Map-Resources available!")
#quit(status = 99)
}
# Check if all filetypes are GeoJSON
if(!all(file_ext(map_resources) %in% c("geojson", "json"))){
print("Not all files provided are either of type GeoJSON or JSON!")
#quit(status = 99)
}
names <- rep(NA, length(map_resources))
for(i in 1:length(map_resources)){
correct <- strsplit(map_resources[i], "[.]")[[1]][1]
names[i] <- correct
}
# Read-in all map-resources
for(i in 1:length(map_resources)){
assign(names[i], geojson_sf(paste(path, "map_resources", map_resources[i], sep = "/")))
}
# Correct Encoding if necessary
# TODO: change index name to either badewetter_index.geojson or index.geojson
for(name in names){
if(name != "badewetter"){
assign(name, convert_to_correct_encoding(get(name), name))
}
}
# Change all to chosen Coordinate System (if not already)
# Get current coordinate system string
# check if coordinate values (geometry) correspond to coord_string
# if not: adjust coordinate string
check_coordinate_system <- function(sf_object){
proj_sf <- st_crs(sf_object)
no_sf <- as.data.frame(sf_object)
coords <- st_coordinates(no_sf[,"geometry"])
if((max(coords[,1]) > 600000)&(max(coords[,2]) > 200000)){
return(epsg[1])
}else if((max(coords[,1] > 1600000))&(max(coords[,2]) > 1200000)){
return(epsg[3])
}else if((max(coords[,1] > 47))&(max(coords[,2] > 7))){
return(epsg[4])
}else{
print("Failed to match potential coordinate system")
return(0)
}
}
check_coordinate_system(badewetter)
check_coordinate_system(swissLakes)
swissLakes
check_coordinate_system(kantone_lines)
check_coordinate_system(swissLakes)
test = as.data.frame(swissLakes)
test
test[,"geometry"]
st_coordinates(test[,"geometry"])
check_coordinate_system <- function(sf_object){
proj_sf <- st_crs(sf_object)
no_sf <- as.data.frame(sf_object)
coords <- st_coordinates(no_sf[,"geometry"])
if((max(coords[,1]) > 600000)&(max(coords[,2]) > 200000)){
return(epsg[1])
}else if((max(coords[,1] > 1600000))&(max(coords[,2]) > 1200000)){
return(epsg[3])
}else if((max(coords[,1] > 8))&(max(coords[,2] > 47))){
return(epsg[4])
}else{
print("Failed to match potential coordinate system")
return(0)
}
}
check_coordinate_system(badewetter)
check_coordinate_system(swissLakes)
check_coordinate_system(kantone_lines)
?st_crs
test2
test3
CRS("+init=epsg:21781")
raster::CRS("+init=epsg:21781")
sp::CRS("+init=epsg:21781")
test_crs = sp::CRS("+init=epsg:21781")
test = badewetter
?st_set_crs
st_set_crs(test, 21781)
# libraries
library(sf)
#library(rjson)
library(tools)
library(geojsonsf)
# Function converts dataset to correct encoding
# takes and returns sf-object
convert_to_correct_encoding <- function(sf_object, type_of_data){
no_sf <- as.data.frame(sf_object)
# convert to correct encoding
if(type_of_data == "kantone_lines"){
Encoding(no_sf$ID1) <- "UTF-8"
}
if(type_of_data == "swissLakes"){
Encoding(no_sf$ID1) <- "UTF-8"
}
# if(any(type_of_data == c("lakes","kantone_lines"))){
#
#   no_sf$ID1 <- iconv(no_sf$ID1, from="ISO-8859-1", to="UTF-8")
#
# }
return(st_as_sf(no_sf))
}
# TODO: check which projections are most practical to use in R
# possible destination crs:
# EPSG: 21781 (swiss projection), 3857 (pseudo-mercator), 2056 (LV95), 4326 (WGS84)
path <-  "data"
# Choose Destination CRS
which_crs <- "LV95"
# CRS-names and EPSG-codes
possible_crs <- c("Swiss Projection", "Pseudo-Mercator", "LV95", "WGS84")
epsg <- c(21781, 3857, 2056, 4326)
index_crs <- which(possible_crs == which_crs)
# Set-up destination projection specifications
dest_crs <- possible_crs[index_crs]
dest_epsg <- epsg[index_crs]
dest_crs
# Reading map-resources files
map_resources <- list.files(paste(path, "map_resources", sep = "/"))
# Check if Map-Resources exist
if(length(map_resources) == 0){
print("No Map-Resources available!")
#quit(status = 99)
}
# Check if all filetypes are GeoJSON
if(!all(file_ext(map_resources) %in% c("geojson", "json"))){
print("Not all files provided are either of type GeoJSON or JSON!")
#quit(status = 99)
}
map_resources
names <- rep(NA, length(map_resources))
for(i in 1:length(map_resources)){
correct <- strsplit(map_resources[i], "[.]")[[1]][1]
names[i] <- correct
}
# Read-in all map-resources
for(i in 1:length(map_resources)){
assign(names[i], geojson_sf(paste(path, "map_resources", map_resources[i], sep = "/")))
}
# Correct Encoding if necessary
# TODO: change index name to either badewetter_index.geojson or index.geojson
# TODO: get river_data input!
for(name in names){
if(name != "badewetter"){
assign(name, convert_to_correct_encoding(get(name), name))
}
}
swiss
# check if coordinate values (geometry) correspond to coord_string
# if not: adjust coordinate string
# then transform to common cordinate reference system
check_coordinate_system <- function(sf_object){
proj_sf <- st_crs(sf_object)
no_sf <- as.data.frame(sf_object)
coords <- st_coordinates(no_sf[,"geometry"])
if((max(coords[,1]) > 600000)&(max(coords[,2]) > 200000)){
return(epsg[1])
}else if((max(coords[,1] > 1600000))&(max(coords[,2]) > 1200000)){
return(epsg[3])
}else if((max(coords[,1] > 8))&(max(coords[,2] > 47))){
return(epsg[4])
}else{
print("Failed to match potential coordinate system")
return(0)
}
}
check_coordinate_system(swissLakes)
check_coordinate_system(badewetter)
check_coordinate_system(kantone_lines)
